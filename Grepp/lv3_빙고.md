# 빙고
## 문제 설명
빙고는 NxN 크기의 게임 보드 칸에 1부터 NxN까지의 자연수를 중복 없이 하나씩 적은 후 숫자를 하나씩 지워나가는 게임입니다. 이때, 가로, 세로, 대각선 방향으로 한 줄에 적힌 숫자를 모두 지울 경우 빙고를 1개 만들었다고 합니다.
다음은 4X4 크기의 게임 보드를 이용해 게임을 진행한 예시입니다.

![image](https://user-images.githubusercontent.com/19163372/118442676-d9c26200-b725-11eb-807b-29017c2052cf.png)

위와 같이 각 칸에 숫자가 적혀 있을 때, 위 게임 보드에서 순서대로 지운 숫자가 [14,3,2,4,13,1,16,11,5,15]인 경우 아래와 같이 빙고 3개가 만들어집니다.

![image](https://user-images.githubusercontent.com/19163372/118442697-e050d980-b725-11eb-81d8-1f8f5a10ad8e.png)

빙고 게임 보드에 적힌 숫자가 담겨있는 배열 board, 게임 보드에서 순서대로 지운 숫자가 들어있는 배열 nums가 매개변수로 주어질 때, board에서 nums에 들어있는 숫자를 모두 지우면 몇 개의 빙고가 만들어지는지 return하도록 solution함수를 완성해주세요.

## 제한사항
- board는 게임 보드 칸에 적힌 숫자를 뜻하는 NxN크기의 2차원 배열이며, N은 2 이상 500이하의 자연수입니다.
- board의 각 칸에는 1 이상 NxN이하의 자연수가 중복 없이 하나씩 들어있습니다.
- nums는 board에서 지울 숫자가 들어있는 배열이며, 길이는 1 이상 NxN이하입니다.
- nums에 들어있는 숫자는 1 이상 NxN이하의 자연수이며, 중복된 수가 들어있지 않습니다.
## 입출력 예
|board|nums|result|
|---|---|---|
|[[11,13,15,16],[12,1,4,3],[10,2,7,8],[5,14,6,9]]|[14,3,2,4,13,1,16,11,5,15]|3|
|[[6,15,17,14,23],[5,12,16,13,25],[21,4,2,1,22],[10,20,3,18,8],[11,9,19,24,7]]|[15,7,2,25,9,16,12,18,5,4,10,13,20]|2|
## 입출력 예 설명
### 입출력 예 #1
문제의 예시와 같습니다.

### 입출력 예 #2
다음 그림과 같이 2개의 빙고가 만들어집니다.

![image](https://user-images.githubusercontent.com/19163372/118442712-e8107e00-b725-11eb-99b0-1aa991dfaff4.png)
# 풀이1
각 행과 열에서 지운 숫자의 갯수와 대각선으로 지워지는 숫자의 갯수를 체크해서, 그 숫자의 갯수가 N이면 빙고라는 생각으로 문제를 풀었다.
```python
def solution(board, nums):
    N = len(board)
    rows = [0] * N
    cols = [0] * N
    X = [0] * 2
    
    for i in range(N):
        for j in range(N):
            if board[i][j] in nums:
                rows[i]+=1
                cols[j]+=1
                if i==j:
                    X[1]+=1
                if i+j==N-1:
                    X[0]+=1
                
    return rows.count(N) + cols.count(N) + X.count(N)
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.2MB)
테스트 2 〉	통과 (0.03ms, 10.3MB)
테스트 3 〉	통과 (0.02ms, 10.3MB)
테스트 4 〉	통과 (0.03ms, 10.2MB)
테스트 5 〉	통과 (0.05ms, 10.2MB)
테스트 6 〉	통과 (0.55ms, 10MB)
테스트 7 〉	통과 (0.01ms, 10.2MB)
테스트 8 〉	통과 (0.02ms, 10.1MB)
테스트 9 〉	통과 (0.02ms, 10MB)
테스트 10 〉	통과 (0.77ms, 10.2MB)
테스트 11 〉	통과 (1.22ms, 10.3MB)
테스트 12 〉	통과 (1.43ms, 10.3MB)
테스트 13 〉	통과 (1.99ms, 10.2MB)
테스트 14 〉	통과 (3.18ms, 10.2MB)
테스트 15 〉	통과 (5.74ms, 10.3MB)
테스트 16 〉	통과 (0.09ms, 10.2MB)
테스트 17 〉	통과 (0.59ms, 10.2MB)
테스트 18 〉	통과 (1.43ms, 10.2MB)
테스트 19 〉	통과 (3.26ms, 10.1MB)
테스트 20 〉	통과 (4.75ms, 10.2MB)
테스트 21 〉	통과 (5.06ms, 10.3MB)
테스트 22 〉	통과 (6.07ms, 10.2MB)
테스트 23 〉	통과 (6.09ms, 10.3MB)
테스트 24 〉	통과 (0.14ms, 10.3MB)
테스트 25 〉	통과 (1.47ms, 10.2MB)
테스트 26 〉	통과 (0.68ms, 10.2MB)
테스트 27 〉	통과 (1.29ms, 10.1MB)
테스트 28 〉	통과 (0.01ms, 10.3MB)
```
효율성  테스트
```
테스트 1 〉	실패 (시간 초과)
테스트 2 〉	실패 (시간 초과)
테스트 3 〉	실패 (시간 초과)
테스트 4 〉	실패 (시간 초과)
테스트 5 〉	실패 (시간 초과)
테스트 6 〉	실패 (시간 초과)
```
정확성 테스트에서는 통과했지만, 2중 반복문을 사용해서인지 효율성 테스트에서 통과하지 못했다. 반복문을 최대한 줄여보고자 했지만 방법을 찾지 못해서 결국 해답을 참고했다..
# 해답
```python
def solution(board, nums):
    n = len(board) # board의 길이
    nums = dict.fromkeys(nums, True) # nums 리스트 값을 키로 변환하여 dict로 만들어준다,
    row_list = [0] * n
    col_list = [0] * n
    left_diagonal = 0
    right_diagonal = 0

    for i in range(n): # O(n)
        for j in range(n): # O(n)
            if board[i][j] in nums: # O(1)
                board[i][j] = 0
                row_list[i] += 1
                col_list[j] += 1
                
                if i == j:
                    left_diagonal += 1
                if n - 1 - i == j:
                    right_diagonal += 1
    
    answer = 0
    answer += sum([1 for i in row_list if i == n]) # 세로
    answer += sum([1 for i in col_list if i == n]) # 가로
    answer += 1 if left_diagonal == n else 0 # 왼쪽 대각선
    answer += 1 if right_diagonal == n else 0 # 오른쪽 대각선

    return answer
```
- 전체적인 알고리즘은 나의 풀이와 비슷하다.
- 여기서는 nums 리스트를 해시로 만들어서 nums안에서 특정 수를 찾을때(if board[i][j] in nums:)의 시간 복잡도를 줄였다.
## 나의 풀이 + 해답
그래서 나의 풀이의 nums에도 해시를 적용해 보았다.
```python
def solution(board, nums):
    N = len(board)
    rows = [0] * N
    cols = [0] * N
    X = [0] * 2
    nums = dict.fromkeys(nums, True)
    
    for i in range(N):
        for j in range(N):
            if board[i][j] in nums:
                rows[i]+=1
                cols[j]+=1
                if i==j:
                    X[1]+=1
                if i+j==N-1:
                    X[0]+=1
    
    return rows.count(N) + cols.count(N) + X.count(N)
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.3MB)
테스트 2 〉	통과 (0.01ms, 10.4MB)
테스트 3 〉	통과 (0.02ms, 10.1MB)
테스트 4 〉	통과 (0.03ms, 10.2MB)
테스트 5 〉	통과 (0.03ms, 10.1MB)
테스트 6 〉	통과 (0.04ms, 10.2MB)
테스트 7 〉	통과 (0.01ms, 10.1MB)
테스트 8 〉	통과 (0.01ms, 10.4MB)
테스트 9 〉	통과 (0.02ms, 10.2MB)
테스트 10 〉	통과 (0.12ms, 10.3MB)
테스트 11 〉	통과 (0.17ms, 10.2MB)
테스트 12 〉	통과 (0.19ms, 10.3MB)
테스트 13 〉	통과 (0.23ms, 10.2MB)
테스트 14 〉	통과 (0.28ms, 10.3MB)
테스트 15 〉	통과 (0.41ms, 10.3MB)
테스트 16 〉	통과 (0.04ms, 10.3MB)
테스트 17 〉	통과 (0.11ms, 10.2MB)
테스트 18 〉	통과 (0.16ms, 10.2MB)
테스트 19 〉	통과 (0.29ms, 10.2MB)
테스트 20 〉	통과 (0.37ms, 10.3MB)
테스트 21 〉	통과 (0.40ms, 10.1MB)
테스트 22 〉	통과 (0.36ms, 10.2MB)
테스트 23 〉	통과 (0.44ms, 10.3MB)
테스트 24 〉	통과 (0.05ms, 10.3MB)
테스트 25 〉	통과 (0.20ms, 10.2MB)
테스트 26 〉	통과 (0.11ms, 10.4MB)
테스트 27 〉	통과 (0.19ms, 10.4MB)
테스트 28 〉	통과 (0.01ms, 10.2MB)
```
효율성  테스트
```
테스트 1 〉	통과 (105.59ms, 43.8MB)
테스트 2 〉	통과 (113.59ms, 44.2MB)
테스트 3 〉	통과 (86.25ms, 44.3MB)
테스트 4 〉	통과 (108.19ms, 44.2MB)
테스트 5 〉	통과 (117.18ms, 46.4MB)
테스트 6 〉	통과 (134.31ms, 46.6MB)
```
역시 효율성 테스트까지 통과했다.

***a in []를 사용할 경우에는 해시를 적극적으로 활용하자***
## dict.fromkeys(x,y)
- x를 키로 하고, 각각의 값을 y로 하는 dictionary를 생성한다.
- ex)
  - dict.fromkeys([1,2,3], 1)
  
    -> {1: 1, 2: 1, 3: 1}
  
  - dict.fromkeys([1,2,3],[4,5,6])
  
    -> {1: [4, 5, 6], 2: [4, 5, 6], 3: [4, 5, 6]}
