# 게임아이템
## 문제 설명
XX 게임의 유저들이 보스 몬스터를 사냥하려고 팀을 만들었습니다. 그리고 팀에 속한 캐릭터에 아이템을 사용해 공격력을 높이려 합니다.

이 게임의 아이템은 캐릭터의 공격력은 높이고 체력을 낮춥니다. 그래서 아이템을 적절히 사용해 팀의 공격력을 최대한 끌어올리려 합니다. 캐릭터별로 아이템을 사용할지 말지는 자유지만, 아이템을 사용한 캐릭터는 체력이 반드시 100 이상 남아야 합니다. 또, 한 캐릭터에 아이템 하나씩만 사용할 수 있으며, 사용한 아이템은 사라집니다.

예를 들어 캐릭터의 체력이 [200, 120, 150]이고 아이템의 효과는 다음과 같습니다.

|높여줄 공격치|낮추는 체력|
|---|---|
|30|100|
|500|30|
|100|400|

이때 팀의 공격력을 최대로 올리려면 첫 번째 캐릭터에 첫 번째 아이템을, 세 번째 캐릭터에 두 번째 아이템을 사용하면 됩니다.

캐릭터들의 체력을 담은 배열 healths와 아이템별 효과를 담은 이차원 배열 items가 solution 함수의 매개변수로 주어질 때, 팀의 공격력을 최고로 끌어올리려면 어떤 아이템을 사용해야 하는지 return 하도록 solution 함수를 완성해주세요.

## 제한 조건
- healths의 길이는 1 이상 10,000 이하입니다.
- healths의 원소(캐릭터의 체력)는 1 이상 1,000,000 이하인 자연수입니다.
- items의 길이는 1 이상 5,000 이하입니다.
- items에는 아이템이 [올려줄 공격력, 낮출 체력]이 번호 순서대로 들어있습니다.
  - 아이템 번호는 1번 부터 시작합니다.
  - items[i]에는 i + 1번 아이템이 [올려줄 공격력, 낮출 체력]이 들어있습니다.
  - 아이템이 올리는 공격력은 1 이상 500,000 이하인 자연수입니다.
  - 아이템이 내리는 체력은 1 이상 500,000 이하인 자연수입니다.
- 아이템 번호는 오름차순으로 정렬해 return 해주세요.
- **올려주는 공격력이 같은 아이템은 없습니다.**
- **아이템을 사용하는 방법이 여러 가지라면, 그러한 방법 중 아무거나 하나를 return 해주세요. 단, 아이템 번호는 오름차순으로 정렬되어 있어야 합니다.**
## 입출력 예
|healths|items|return|
|---|---|---|
|[200,120,150]|[[30,100],[500,30],[100,400]]|[1,2]|
|[300,200,500]|[[1000, 600], [400, 500], [300, 100]]|[3]|
### 입출력 예 #1
문제의 예시와 같습니다.

### 입출력 예 #2

첫 번째, 두 번째 아이템을 사용하면 캐릭터의 체력이 100 미만이 됩니다. 따라서 세 번째 아이템만 사용할 수 있습니다.
# 풀이1
아이템이 높여주는 공격력이 높을수록, 낮아지는 체력이 적을수록 좋다.

하지만, 역시 높여주는 공격력이 더 우선이므로, 먼저 낮아지는 체력이 낮은 순으로 정렬하고, 그 다음 높여주는 공격력이 높은 순으로 아이템을 정렬했다.

그 이후, 체력이 낮은 캐릭터 순으로 높여주는 공격력이 높은 아이템부터 조사를 했더니, 쉽게 답을 구할 수 있었다.
```python
def solution(healths, items):
    answer = []
    items_copy = sorted(items, key=lambda x:x[1])
    items_copy.sort(reverse=True)
    healths.sort()
    for item in items_copy:
        up, down = item
        for health in healths:
            if health >= 100+down:
                answer.append(item)
                healths.remove(health)
                break
    return [items.index(i)+1 for i in items if i in answer]
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.2MB)
테스트 2 〉	통과 (0.02ms, 10.3MB)
테스트 3 〉	통과 (0.03ms, 10.2MB)
테스트 4 〉	통과 (0.05ms, 10.2MB)
테스트 5 〉	통과 (0.25ms, 10.2MB)
테스트 6 〉	통과 (4.63ms, 10.4MB)
테스트 7 〉	통과 (5.59ms, 10.4MB)
테스트 8 〉	통과 (1.13ms, 10.2MB)
테스트 9 〉	통과 (2.87ms, 10.2MB)
테스트 10 〉	통과 (989.22ms, 11.8MB)
테스트 11 〉	통과 (2089.94ms, 11.1MB)
테스트 12 〉	통과 (2088.58ms, 11.1MB)
테스트 13 〉	통과 (0.04ms, 10.3MB)
테스트 14 〉	통과 (0.05ms, 10.2MB)
테스트 15 〉	통과 (0.01ms, 10.2MB)
테스트 16 〉	통과 (0.02ms, 10.2MB)
테스트 17 〉	통과 (0.01ms, 10.2MB)
테스트 18 〉	통과 (0.96ms, 10.2MB)
테스트 19 〉	통과 (26.06ms, 10.4MB)
테스트 20 〉	통과 (47.34ms, 10.5MB)
```
효율성  테스트
```
테스트 1 〉	실패 (시간 초과)
테스트 2 〉	실패 (시간 초과)
```
그러나 효율성 테스트에서 낮은 점수를 보였다.

현재의 2중 반복문 + 1중 반복문 구조의 복잡도를 줄일 수 있는 방법을 생각해봐야겠다..
# 
heap을 써서 복잡도를 줄인다면 효율성 테스트를 통과하지 않을까 생각했지만, 그렇지 않았다. 그래서 결국 풀이를 참고했다.

풀이를 이해하기 위해서는 우선 dequeue의 사용법을 알아야 한다.
> ## collections.dequeue
> dequeue는 스택과 큐의 기능을 모두 가진 자료구조로, 한개의 객체로 동시에 스택과 큐처럼 사용 가능하다.
> ### 스택 메서드
> - `append()`: 오른쪽 끝에 입력
> - `pop()`: 오른쪽 끝에서 출력
> ### 큐 메서드
> - `appendleft()`: 왼쪽 끝에 입력
> - `pop()`: 오른쪽 끝에서 출력
> - `append()`: 오른쪽 끝에 입력
> - `popleft()`: 왼쪽 끝에서 출력
> ### 그 밖의 메서드
> - `extend()`, `extendleft()`: 각각 오른쪽, 왼쪽에 확장
> - `insert()`, `remove()`: 리스트의 `insert()`, `remove()`와 같다
> - `reverse()`: 내용의 순서를 반전

그러면 이제 풀이의 코드를 보자
```python
from heapq import heapify, heappush, heappop
from collections import deque

def solution(healths, items):
    healths.sort()
    items = sorted([(item[1], item[0], index+1) for index, item in enumerate(items)])       # 깎는 체력이 낮은 순으로 정렬 + 인덱스 같이 저장
    items = deque(items)        # dequeue 적용
    answer = []
    heap = []

    for health in healths:      # 낮은 체력부터
        while items:        # 깎는 체력이 낮은 아이템부터
            debuff, buff, index = items[0]
            if health - debuff < 100:   # 사용할 수 없는 아이템이 나오기 시작할때 break
                break
            items.popleft()     # 사용한 아이템 제거
            heappush(heap, (-buff, index))      # 사용 가능한 아이템들 heappush (이전 캐릭터가 heappush했던 아이템들도 유지)
        # 현재 힙에는 사용할 수 있는 아이템들이 공격력을 많이 올려주는 순서로 들어잇음
        if heap:
            _, index = heappop(heap)    # 사용가능 아이템 중 가장 공격력을 많이 올려주는 아이템 선택
            answer.append(index)        # 그 아이템의 index 추가

    return sorted(answer)
```
- 내 풀이와는 다르게, items나 health 배열을 순회할 때 중복해서 순회하는 경우를 없애서, 같은 2중 반복문임에도 불구하고 복잡도를 크게 줄일 수 있었다.
- 낮은 체력부터 사용가능한 아이템만을 보면서 후보로 지정하고, 아이템을 고를때는 공격력을 가장 많이 높여주는 아이템을 선택하는 전략
